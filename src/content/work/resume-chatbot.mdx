---
title: "AI-Powered Resume Builder with Real-Time Streaming"
description: "Building an intelligent resume editor using Next.js, Vercel AI SDK, and surgical JSON patching for real-time collaborative editing."
company: "Personal Project"
role: "Full-Stack Developer"
startDate: 2024-11-01
featured: true
tags: ["AI", "Next.js", "Streaming", "Real-time"]
image: "../../assets/images/projects/resume-chatbot.png"
category: "AI APPLICATION"
impact: "REAL-TIME COLLABORATIVE EDITING WITH AI-POWERED RESUME OPTIMIZATION."
stack: ["NEXT.JS", "VERCEL AI SDK", "DRIZZLE ORM", "+4"]
roleCategory: "FULL-STACK DEVELOPER"
---

import LazyVideo from '../../components/LazyVideo.astro';

# AI-Powered Resume Builder with Real-Time Streaming

## Problem overview: document drift in conversational editors

Conversational editors that regenerate entire documents cause document drift over repeated edits. Small changes accumulate: duplicated sections, format loss, and stealth reordering. For structured artifacts like resumes, these errors are visible and costly. The core requirement is to preserve conversational UX while eliminating cumulative state corruption.

## Architecture overview: three-layer streaming pipeline

High-level runtime: a single-purpose pipeline with clear boundaries. Each layer has one responsibility so reasoning, testing, and failure modes remain isolated.

### Layers

- **Conversation Agent:** handles intent reasoning and tool routing.
- **Patch Tool:** emits RFC 6902 operations from structured requests.
- **Patch Application:** validates and applies safe mutations in the client.

<figure class="my-10 border-4 border-base-content bg-base-100 p-3 shadow-[8px_8px_0_0_rgba(0,0,0,0.9)]">
  <img src="/assets/diagrams/resume-chatbot-architecture.svg" alt="Three-layer architecture diagram" loading="lazy" />
  <figcaption class="mt-3 text-sm font-semibold uppercase tracking-wide text-base-content/65">
    Architecture overview: conversation layer, patch tool layer, and patch application layer.
  </figcaption>
</figure>

## Stream semantics: text streams vs object/tool-call streams

Streaming raw text and streaming structured objects are different contracts. Text streams carry language; object streams carry typed operations. Treat object streams as authoritative, validate them, and avoid re-parsing textual tokens into state.

- **Text stream contract:** human-facing output for explanation and conversational flow.
- **Object/tool-call contract:** machine-facing operations for precise, schema-valid state updates.

<figure class="my-10 border-4 border-base-content bg-base-100 p-3 shadow-[8px_8px_0_0_rgba(0,0,0,0.9)]">
  <img src="/assets/diagrams/resume-chatbot-stream-types.svg" alt="Text stream versus object tool-call stream with validation boundary" loading="lazy" />
  <figcaption class="mt-3 text-sm font-semibold uppercase tracking-wide text-base-content/65">
    Concept model: text stream for UX, object stream for mutation, validation boundary in between.
  </figcaption>
</figure>

Path stabilization and schema validation bridge the streams: object tokens must be syntactically complete before application.

## Demo overview: what the demo shows and why it follows the concepts

The demo showcases surgical RFC 6902 patches arriving progressively and being applied without full-document replacements. It demonstrates reduced UI churn, preserved formatting, and deterministic application under mock providers.

<LazyVideo 
  videoUrl="https://drive.google.com/file/d/1Hb6bH99F8uEqPU7BhpI4fS0UTeuEhrhC/preview"
  thumbnailSrc="/assets/images/projects/resume-chatbot-demo-frame.webp"
  thumbnailAlt="Resume chatbot demo showing real-time streaming edits"
  caption="The resume chatbot applying surgical JSON patches in real-time"
/> 

## Testing overview: strategy and high-level results

Testing splits into deterministic model mocks and schema assertions. Replace external model calls with mock providers, then assert final resume JSON against the schema rather than fragile UI timings.

- **Deterministic mocks:** remove network and model variability from primary checks.
- **Schema assertions:** verify final JSON correctness without timing fragility.

Results:

- Before: test stability ~50%, avg 28.8s per test
- After: test stability 100%, avg 9.2s per test

For the full harness design and reliability methodology, see [Deterministic Testing for AI Streaming](/work/resume-chatbot-testing-strategy).

## Handoff: deep dives and next reading

This page is an overview and hub. Follow the deep dives for implementation detail and test patterns.

- [Streaming JSON Patching Architecture](/work/resume-chatbot-streaming-architecture): detailed pipeline internals, stabilization mechanics, and operation lifecycle.
- [Deterministic Testing for AI Streaming](/work/resume-chatbot-testing-strategy): mock-provider design, synchronization strategy, and reliability benchmarks.

## Implementation notes and caveats

- **Progressive stream:** use `partialObjectStream` for incremental structured payloads.
- **Validation first:** verify operations with `fast-json-patch` before mutation.
- **Stable emission:** keep the patch model fixed for predictable operation shape.
- **Safety fallback:** for large destructive edits, use guarded full-document operations.

## Appendix: simplified server handler

```ts
// /api/patch-resume.ts (simplified)
import { streamObject } from 'ai-sdk';
import { patchSchema } from '~/lib/schemas/patch';

export async function POST(req) {
  const { changes } = await req.json();
  const result = await streamObject({ model: getArtifactModel(), schema: patchSchema, prompt: `Generate patches for: ${changes}` });
  return new Response(result.stream);
}
```

## Lessons learned

- **Streaming partial objects:** reduces perceived latency and UI churn.
- **Clear boundaries:** make debugging and testing substantially easier.
- **Schema validation:** prevents invalid model operations from corrupting state.
- **Deterministic mocks:** are required for fast, stable E2E reliability.
