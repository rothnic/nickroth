---
title: "Persistent Filter Bar with View Transitions"
description: "A deep dive into building a horizontally-scrollable filter component that maintains scroll position, hover states, and active styling across page transitions using Astro's View Transitions API."
company: "Personal Project"
role: "Frontend Developer"
startDate: 2024-12-15
featured: false
tags: ["View Transitions", "Astro", "UX", "CSS", "JavaScript"]
category: "WEB PLATFORMS"
impact: "SEAMLESS CATEGORY FILTERING WITH PROFESSIONAL POLISH—NO SCROLL JUMPS, NO HOVER FLICKER."
stack: ["ASTRO 5", "VIEW TRANSITIONS", "SESSION STORAGE", "CSS ANIMATIONS"]
roleCategory: "FRONTEND DEVELOPER"
parentProject: "astro-portfolio-ai-development"
---

# Persistent Filter Bar with View Transitions

## The Challenge

Category filter bars are deceptively complex. Users expect:
- **Scroll position memory** — Don't reset to the left when changing categories
- **Smooth active state transitions** — The selected filter should feel interactive
- **Hover state continuity** — Clicks shouldn't cause visual "drops" during navigation
- **Vertical scroll preservation** — The page shouldn't jump to top when filtering

With traditional MPAs, each category is a new page load—scroll positions reset, hover states vanish, and the experience feels disconnected. With Astro's View Transitions API, we can achieve SPA-like polish while retaining static route benefits.

## Key Insight: `transition:persist`

The breakthrough came from using Astro's `transition:persist` directive. Instead of swapping the filter bar element during page transitions, we keep the **actual DOM element** alive:

```astro
<nav 
  id="work-category-nav"
  transition:name="work-category-nav"
  transition:persist
  class="flex flex-nowrap gap-3 overflow-x-auto"
>
  {categories.map(cat => (
    <a href={`/work/category/${slugify(cat)}`}
       class={cat === activeCategory ? 'btn-accent' : 'btn-outline'}>
      {cat}
    </a>
  ))}
</nav>
```

### What This Preserves

| State | Without `persist` | With `persist` |
|-------|-------------------|----------------|
| Scroll position | Resets to 0 | Maintained |
| `:hover` state | Lost | Maintained |
| Ongoing animations | Interrupted | Continue |
| Event listeners | Need re-binding | Already bound |

### The Trade-off: Manual State Sync

Since the DOM element persists, it **doesn't update from server rendering**. We must manually sync which button appears active:

```javascript
document.addEventListener('astro:after-swap', () => {
  const nav = document.getElementById('work-category-nav');
  const currentPath = window.location.pathname;
  
  nav?.querySelectorAll('a').forEach(btn => {
    const href = btn.getAttribute('href');
    const isActive = href === currentPath || 
      (currentPath === '/work' && href === '/work');
    
    btn.classList.toggle('btn-accent', isActive);
    btn.classList.toggle('btn-outline', !isActive);
    
    if (isActive) {
      btn.setAttribute('aria-current', 'page');
    } else {
      btn.removeAttribute('aria-current');
    }
  });
});
```

## Scroll Position Strategy: The Delta-Restoration Pattern

For filter bar scroll positions, we use a dual-layered approach:

### 1. Horizontal Scroll (Always Restore)

The filter bar's `scrollLeft` should always be restored—whether navigating between filters or returning from a detail page:

```javascript
const SCROLL_KEY = 'filterScrollPos';

// Save on any navigation
document.addEventListener('astro:before-preparation', () => {
  const nav = document.getElementById('work-category-nav');
  if (nav) sessionStorage.setItem(SCROLL_KEY, nav.scrollLeft);
});

// Restore in after-swap (before visible)
document.addEventListener('astro:after-swap', () => {
  const nav = document.getElementById('work-category-nav');
  const saved = sessionStorage.getItem(SCROLL_KEY);
  if (nav && saved) nav.scrollLeft = parseInt(saved, 10);
});
```

### 2. Vertical Scroll (Conditional)

Vertical page scroll should only be restored for filter-to-filter navigation. For browser back button, let the browser's native restoration handle it:

```javascript
const PAGE_SCROLL_KEY = 'pageVerticalScroll';
const NAV_FLAG_KEY = 'isFilterNavigation';

// Mark filter clicks
nav.addEventListener('click', (e) => {
  if (e.target.closest('a')) {
    sessionStorage.setItem(NAV_FLAG_KEY, 'true');
    sessionStorage.setItem(PAGE_SCROLL_KEY, window.scrollY);
  }
});

// Restore conditionally
document.addEventListener('astro:after-swap', () => {
  const isFilterNav = sessionStorage.getItem(NAV_FLAG_KEY) === 'true';
  sessionStorage.removeItem(NAV_FLAG_KEY);
  
  if (isFilterNav) {
    const saved = sessionStorage.getItem(PAGE_SCROLL_KEY);
    if (saved) window.scrollTo(0, parseInt(saved, 10));
  }
});
```

## Visual Feedback: Click Animation

Add tactile feedback when users click filters:

```css
@keyframes filter-btn-pulse {
  0% { transform: scale(1); }
  50% { transform: scale(0.95); filter: brightness(1.1); }
  100% { transform: scale(1); }
}

.filter-btn-animate {
  animation: filter-btn-pulse 0.2s ease-out;
}
```

```javascript
nav.addEventListener('click', (e) => {
  const link = e.target.closest('a');
  if (link) {
    link.classList.add('filter-btn-animate');
    link.addEventListener('animationend', () => {
      link.classList.remove('filter-btn-animate');
    }, { once: true });
  }
});
```

## Edge Fade Indicators

Show scroll affordance with fade overlays:

```astro
<div class="relative">
  <!-- Left fade -->
  <div 
    id="filter-fade-left"
    class="absolute left-0 w-12 h-full bg-gradient-to-r 
           from-base-100 to-transparent pointer-events-none z-10"
    style="opacity: 0"
  />
  
  <nav id="work-category-nav">...</nav>
  
  <!-- Right fade -->
  <div 
    id="filter-fade-right"
    class="absolute right-0 w-12 h-full bg-gradient-to-l 
           from-base-100 to-transparent pointer-events-none z-10"
    style="opacity: 1"
  />
</div>
```

Update visibility based on scroll position:

```javascript
function updateFades() {
  const nav = document.getElementById('work-category-nav');
  const fadeLeft = document.getElementById('filter-fade-left');
  const fadeRight = document.getElementById('filter-fade-right');
  
  const { scrollLeft, scrollWidth, clientWidth } = nav;
  const maxScroll = scrollWidth - clientWidth;
  
  fadeLeft.style.opacity = scrollLeft > 5 ? '1' : '0';
  fadeRight.style.opacity = scrollLeft < maxScroll - 5 ? '1' : '0';
}

nav.addEventListener('scroll', updateFades);
```

## Why Not Client-Side Filtering?

Static routes (`/work/category/automation-ai`) provide:

- **SEO-friendly URLs** — Each category is crawlable
- **Shareable links** — Users can share filtered views
- **No JavaScript required** — Works with JS disabled
- **Browser history integration** — Back button works naturally

The View Transitions API gives us SPA-like polish without sacrificing these benefits.

## Related

- [Building an Astro Portfolio with AI-Assisted Development](/work/astro-portfolio-ai-development) — Parent project
- [Navbar Active State Morphing](/work/view-transitions-navbar) — Navigation animation patterns
