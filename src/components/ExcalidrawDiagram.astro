---
// ExcalidrawDiagram - Theme-aware diagram component using CSS variables
// Based on https://alexop.dev/posts/excalidraw-dark-mode-astro-diagrams/
// Uses Excalidraw's official theme color mappings
// Lazy loads via IntersectionObserver - fetch is deferred until near viewport
export interface Props {
  src: string;
  alt: string;
  caption?: string;
  height?: string;
}

const { src, alt, caption, height = '400px' } = Astro.props;
---

<figure class="excalidraw-figure">
  <div class="excalidraw-container p-3" data-svg-url={src} aria-label={alt} data-lazy="true" style={`height: ${height};`}>
    <!-- Placeholder shown while diagram is loading or off-screen -->
    <div class="excalidraw-placeholder" aria-hidden="true" style={`height: ${height};`}>
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="1.5"/>
        <path d="M3 9h18M9 21V9" stroke="currentColor" stroke-width="1.5"/>
      </svg>
      <span>Loading diagram...</span>
    </div>
  </div>
  {caption && (
    <figcaption class="excalidraw-caption">{caption}</figcaption>
  )}
</figure>

<script>
  // Color mapping from Excalidraw's theme system
  // Light mode colors that should be replaced with CSS variables
  const LIGHT_COLORS: Record<string, string> = {
    // Background/surface colors
    '#ffffff': 'var(--excalidraw-bg)',
    '#f5f5f5': 'var(--excalidraw-surface-high)',
    '#ebebeb': 'var(--excalidraw-surface-mid)',
    '#f1f0ff': 'var(--excalidraw-surface-low)',
    '#ececf4': 'var(--excalidraw-surface-lowest)',
    '#fff': 'var(--excalidraw-bg)',
    'white': 'var(--excalidraw-bg)',
    
    // Text/content colors
    '#1b1b1f': 'var(--excalidraw-text)',
    '#1e1e1e': 'var(--excalidraw-text-secondary)',
    '#121212': 'var(--excalidraw-text-muted)',
    '#000000': 'var(--excalidraw-text)',
    '#000': 'var(--excalidraw-text)',
    'black': 'var(--excalidraw-text)',
    
    // Gray scale
    '#3d3d3d': 'var(--excalidraw-gray-80)',
    '#5c5c5c': 'var(--excalidraw-gray-70)',
    '#7a7a7a': 'var(--excalidraw-gray-60)',
    '#999999': 'var(--excalidraw-gray-50)',
    '#b8b8b8': 'var(--excalidraw-gray-40)',
    '#d6d6d6': 'var(--excalidraw-gray-30)',
    '#242424': 'var(--excalidraw-gray-85)',
    
    // Brand/primary colors
    '#6965db': 'var(--excalidraw-primary)',
    '#5b57d1': 'var(--excalidraw-primary-darker)',
    '#e3e2fe': 'var(--excalidraw-primary-light)',
    
    // Semantic colors
    '#db6965': 'var(--excalidraw-danger)',
    '#fceeca': 'var(--excalidraw-warning)',
    '#cafccc': 'var(--excalidraw-success)',
  };
  
  function modifySvg(svgString: string): string {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgString, 'image/svg+xml');
    const svg = doc.documentElement;
    
    // Let SVG use intrinsic dimensions (hug its content)
    svg.removeAttribute('width');
    svg.removeAttribute('height');
    svg.classList.add('excalidraw-svg');
    
    // Replace hardcoded colors with CSS variables
    const allElements = svg.querySelectorAll('*');
    allElements.forEach(el => {
      const fill = el.getAttribute('fill');
      const stroke = el.getAttribute('stroke');
      if (fill && LIGHT_COLORS[fill.toLowerCase()]) {
        el.setAttribute('fill', LIGHT_COLORS[fill.toLowerCase()]);
      }
      
      if (stroke && LIGHT_COLORS[stroke.toLowerCase()]) {
        el.setAttribute('stroke', LIGHT_COLORS[stroke.toLowerCase()]);
      }
      
      // Handle style attribute with fill/stroke
      const style = el.getAttribute('style');
      if (style) {
        let newStyle = style;
        Object.entries(LIGHT_COLORS).forEach(([color, variable]) => {
          const regex = new RegExp(color, 'gi');
          newStyle = newStyle.replace(regex, variable);
        });
        if (newStyle !== style) {
          el.setAttribute('style', newStyle);
        }
      }
    });
    
    return new XMLSerializer().serializeToString(svg);
  }
  
  async function loadDiagram(container: HTMLElement) {
    const svgUrl = container.dataset.svgUrl;
    if (!svgUrl || container.dataset.loaded === 'true') return;

    // Mark as loading to prevent duplicate fetches
    container.dataset.loaded = 'true';

    try {
      const response = await fetch(svgUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch SVG: ${response.statusText}`);
      }

      const svgData = await response.text();
      const modifiedSvg = modifySvg(svgData);
      container.innerHTML = modifiedSvg;
    } catch (error) {
      console.error('Error loading Excalidraw diagram:', error);
      // Fallback: show error state in placeholder
      const placeholder = container.querySelector('.excalidraw-placeholder');
      if (placeholder) {
        placeholder.innerHTML = '<span>Diagram unavailable</span>';
      }
      container.dataset.loaded = 'false';
    }
  }

  function initExcalidrawDiagrams() {
    const containers = document.querySelectorAll<HTMLElement>(
      '.excalidraw-container[data-lazy="true"]'
    );

    if (!containers.length) return;

    // Use IntersectionObserver to lazy load diagrams near the viewport
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const container = entry.target as HTMLElement;
            loadDiagram(container);
            // Stop observing once triggered - no need to re-fire
            observer.unobserve(container);
          }
        });
      },
      {
        // Start loading 200px before diagram enters viewport
        rootMargin: '200px 0px',
        threshold: 0,
      }
    );

    containers.forEach(container => {
      // Reset loaded state on page transitions
      container.dataset.loaded = 'false';
      observer.observe(container);
    });
  }
  
  // Run on initial page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initExcalidrawDiagrams);
  } else {
    initExcalidrawDiagrams();
  }
  
  // Run on Astro page transitions
  document.addEventListener('astro:page-load', initExcalidrawDiagrams);
</script>

<style>
  .excalidraw-figure {
    margin: 2rem auto;
    padding: 1rem;
    border: 2px solid var(--nr-border-color);
    background: var(--color-base-100);
    box-shadow: var(--nr-shadow-sm);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: min-content;
    max-width: 100%;
  }

  .excalidraw-container {
    width: max-content;
    max-width: 100%;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: fit-content;
  }

  /* Placeholder shown while diagram is off-screen or loading */
  .excalidraw-placeholder {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 2rem;
    color: color-mix(in oklab, var(--color-base-content) 40%, #0000);
    font-size: 0.875rem;
    /* height is set inline to match container - prevents CLS */
    justify-content: center;
  }

  .excalidraw-placeholder svg {
    width: 32px;
    height: 32px;
    opacity: 0.4;
  }
  
  .excalidraw-container :global(svg) {
    /* Stretch to fill container height, maintain aspect ratio */
    height: 100%;
    width: auto;
    max-width: 100%;
    max-height: 100%;
    display: block;
  }
  
  .excalidraw-caption {
    margin-top: 1rem;
    font-size: 0.875rem;
    color: var(--color-base-content);
    text-align: center;
    font-style: italic;
  }
</style>

<style>
  /* Scoped Excalidraw theme variables - only apply within this component */
  .excalidraw-container {
    /* Light mode (default) - Excalidraw colors */
    --excalidraw-bg: #ffffff;
    --excalidraw-surface-high: #f5f5f5;
    --excalidraw-surface-mid: #ebebeb;
    --excalidraw-surface-low: #f1f0ff;
    --excalidraw-surface-lowest: #ececf4;
    
    --excalidraw-text: #1b1b1f;
    --excalidraw-text-secondary: #1e1e1e;
    --excalidraw-text-muted: #121212;
    
    --excalidraw-gray-80: #3d3d3d;
    --excalidraw-gray-70: #5c5c5c;
    --excalidraw-gray-60: #7a7a7a;
    --excalidraw-gray-50: #999999;
    --excalidraw-gray-40: #b8b8b8;
    --excalidraw-gray-30: #d6d6d6;
    --excalidraw-gray-85: #242424;
    
    --excalidraw-primary: #6965db;
    --excalidraw-primary-darker: #5b57d1;
    --excalidraw-primary-light: #e3e2fe;
    
    --excalidraw-danger: #db6965;
    --excalidraw-warning: #fceeca;
    --excalidraw-success: #cafccc;
  }
  
  /* Dark mode - Excalidraw colors scoped to component */
  :global([data-theme="neobrutalism-dark"]) .excalidraw-container {
    --excalidraw-bg: #121212;
    --excalidraw-surface-high: #2e2d39;
    --excalidraw-surface-mid: #232329;
    --excalidraw-surface-low: #2e2d39;
    --excalidraw-surface-lowest: #1e1e1e;
    
    --excalidraw-text: #e3e3e8;
    --excalidraw-text-secondary: #e3e3e8;
    --excalidraw-text-muted: #e3e3e8;
    
    --excalidraw-gray-80: #b8b8b8;
    --excalidraw-gray-70: #999999;
    --excalidraw-gray-60: #7a7a7a;
    --excalidraw-gray-50: #5c5c5c;
    --excalidraw-gray-40: #3d3d3d;
    --excalidraw-gray-30: #2e2e2e;
    --excalidraw-gray-85: #d6d6d6;
    
    --excalidraw-primary: #a8a5ff;
    --excalidraw-primary-darker: #b2aeff;
    --excalidraw-primary-light: #4f4d6f;
    
    --excalidraw-danger: #ffa8a5;
    --excalidraw-warning: #f5c354;
    --excalidraw-success: #a5eba8;
  }
  
  /* Smooth transitions for theme changes */
  .excalidraw-container :global(.excalidraw-svg),
  .excalidraw-container :global(.excalidraw-svg *) {
    transition: fill 0.3s ease, stroke 0.3s ease;
  }
</style>