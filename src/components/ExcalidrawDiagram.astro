---
// ExcalidrawDiagram - Theme-aware diagram component using class-replacement approach
// Based on https://alexop.dev/posts/excalidraw-dark-mode-astro-diagrams/
// Parses SVG at runtime, strips hardcoded fill/stroke, adds semantic CSS classes
// that map to DaisyUI theme variables for automatic light/dark adaptation.
// Lazy loads via IntersectionObserver - fetch is deferred until near viewport.
export interface Props {
  src: string;
  alt: string;
  caption?: string;
  height?: string;
}

const { src, alt, caption, height = '400px' } = Astro.props;
---

<figure class="excalidraw-figure">
  <div class="excalidraw-container p-3" data-svg-url={src} aria-label={alt} data-lazy="true" style={`height: ${height};`}>
    <!-- Placeholder shown while diagram is loading or off-screen -->
    <div class="excalidraw-placeholder" aria-hidden="true" style={`height: ${height};`}>
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="1.5"/>
        <path d="M3 9h18M9 21V9" stroke="currentColor" stroke-width="1.5"/>
      </svg>
      <span>Loading diagram...</span>
    </div>
  </div>
  {caption && (
    <figcaption class="excalidraw-caption">{caption}</figcaption>
  )}
</figure>

<script>
  /**
   * Strips hardcoded fill/stroke attributes from SVG elements and adds semantic
   * CSS classes so DaisyUI theme variables control colors automatically.
   *
   * Classes added:
   *   excalidraw-bg      - background rect (first direct-child rect of <svg>)
   *   excalidraw-fill    - other filled rects and shapes
   *   excalidraw-text    - text elements
   *   excalidraw-stroke  - path/line/polyline/etc. strokes
   *
   * fill="none" and stroke="none" values are preserved (structural, not color).
   */
  function processExcalidrawSvg(svgString: string): string {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgString, 'image/svg+xml');
    const svg = doc.documentElement;

    svg.removeAttribute('width');
    svg.removeAttribute('height');
    svg.classList.add('excalidraw-svg');

    // Background rect - first <rect> direct child of <svg>
    const bgRect = svg.querySelector(':scope > rect:first-of-type');
    if (bgRect) {
      bgRect.removeAttribute('fill');
      bgRect.removeAttribute('stroke');
      bgRect.classList.add('excalidraw-bg');
    }

    // Other rects (boxes, cards)
    doc.querySelectorAll('rect').forEach(rect => {
      if (rect === bgRect) return;
      if (rect.getAttribute('fill') === 'none') return;
      rect.removeAttribute('fill');
      rect.classList.add('excalidraw-fill');
    });

    // Text elements
    doc.querySelectorAll('text').forEach(text => {
      if (text.getAttribute('fill') === 'none') return;
      text.removeAttribute('fill');
      text.classList.add('excalidraw-text');
    });

    // Paths, lines, polylines, polygons, ellipses, circles
    doc.querySelectorAll('path, line, polyline, polygon, ellipse, circle').forEach(el => {
      const stroke = el.getAttribute('stroke');
      const fill = el.getAttribute('fill');
      if (stroke && stroke !== 'none') {
        el.removeAttribute('stroke');
        el.classList.add('excalidraw-stroke');
      }
      if (fill && fill !== 'none') {
        el.removeAttribute('fill');
        el.classList.add('excalidraw-fill');
      }
    });

    return new XMLSerializer().serializeToString(svg);
  }

  async function loadDiagram(container: HTMLElement) {
    const svgUrl = container.dataset.svgUrl;
    if (!svgUrl) return;

    try {
      const response = await fetch(svgUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch SVG: ${response.statusText}`);
      }
      const svgData = await response.text();
      const modifiedSvg = processExcalidrawSvg(svgData);
      container.innerHTML = modifiedSvg;
      container.dataset.loaded = 'true';
    } catch (error) {
      console.error('Error loading Excalidraw diagram:', error);
      const placeholder = container.querySelector('.excalidraw-placeholder');
      if (placeholder) {
        placeholder.innerHTML = '<span>Diagram unavailable</span>';
      }
    }
  }

  function initExcalidrawDiagrams() {
    const containers = document.querySelectorAll<HTMLElement>(
      '.excalidraw-container[data-lazy="true"]'
    );

    if (!containers.length) return;

    // Use IntersectionObserver to lazy load diagrams near the viewport
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const container = entry.target as HTMLElement;
            loadDiagram(container);
            // Stop observing once triggered - no need to re-fire
            observer.unobserve(container);
          }
        });
      },
      {
        // Start loading 200px before diagram enters viewport
        rootMargin: '200px 0px',
        threshold: 0,
      }
    );

    containers.forEach(container => {
      // Reset loaded state on page transitions
      container.dataset.loaded = 'false';
      observer.observe(container);
    });
  }
  
  // Run on initial page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initExcalidrawDiagrams);
  } else {
    initExcalidrawDiagrams();
  }
  
  // Run on Astro page transitions
  document.addEventListener('astro:page-load', initExcalidrawDiagrams);
</script>

<style>
  .excalidraw-figure {
    margin: 2rem auto;
    padding: 1rem;
    border: 2px solid var(--nr-border-color);
    background: var(--color-base-100);
    box-shadow: var(--nr-shadow-sm);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: min-content;
    max-width: 100%;
  }

  .excalidraw-container {
    width: max-content;
    max-width: 100%;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: fit-content;
  }

  /* Placeholder shown while diagram is off-screen or loading */
  .excalidraw-placeholder {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 2rem;
    color: color-mix(in oklab, var(--color-base-content) 40%, #0000);
    font-size: 0.875rem;
    /* height is set inline to match container - prevents CLS */
    justify-content: center;
  }

  .excalidraw-placeholder svg {
    width: 32px;
    height: 32px;
    opacity: 0.4;
  }
  
  .excalidraw-container :global(svg) {
    /* Stretch to fill container height, maintain aspect ratio */
    height: 100%;
    width: auto;
    max-width: 100%;
    max-height: 100%;
    display: block;
  }
  
  /* -----------------------------------------------------------------------
     Semantic color classes applied by processExcalidrawSvg()
     Maps Excalidraw's visual roles to DaisyUI theme variables.
     DaisyUI updates the CSS variables automatically when data-theme changes.
  ----------------------------------------------------------------------- */

  /* Background rect - transparent so it inherits the figure's bg */
  .excalidraw-container :global(.excalidraw-bg) {
    fill: transparent;
  }

  /* Filled shapes (boxes, cards, highlight rects) */
  .excalidraw-container :global(.excalidraw-fill) {
    fill: var(--color-base-200);
  }

  /* Text elements */
  .excalidraw-container :global(.excalidraw-text) {
    fill: var(--color-base-content);
  }

  /* Strokes (paths, arrows, borders, connectors) */
  .excalidraw-container :global(.excalidraw-stroke) {
    stroke: var(--color-base-content);
  }

  .excalidraw-caption {
    margin-top: 1rem;
    font-size: 0.875rem;
    color: var(--color-base-content);
    text-align: center;
    font-style: italic;
  }
</style>