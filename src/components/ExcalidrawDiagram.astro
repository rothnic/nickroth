---
// ExcalidrawDiagram - Theme-aware diagram component using CSS filter approach
// Based on https://alexop.dev/posts/excalidraw-dark-mode-astro-diagrams/
// Uses CSS filter inversion for dark mode instead of color replacement
// Lazy loads via IntersectionObserver - fetch is deferred until near viewport
export interface Props {
  src: string;
  alt: string;
  caption?: string;
  height?: string;
}

const { src, alt, caption, height = '400px' } = Astro.props;
---

<figure class="excalidraw-figure">
  <div class="excalidraw-container p-3" data-svg-url={src} aria-label={alt} data-lazy="true" style={`height: ${height};`}>
    <!-- Placeholder shown while diagram is loading or off-screen -->
    <div class="excalidraw-placeholder" aria-hidden="true" style={`height: ${height};`}>
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="1.5"/>
        <path d="M3 9h18M9 21V9" stroke="currentColor" stroke-width="1.5"/>
      </svg>
      <span>Loading diagram...</span>
    </div>
  </div>
  {caption && (
    <figcaption class="excalidraw-caption">{caption}</figcaption>
  )}
</figure>

<script>
  async function loadDiagram(container: HTMLElement) {
    const svgUrl = container.dataset.svgUrl;
    if (!svgUrl) return;

    try {
      const response = await fetch(svgUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch SVG: ${response.statusText}`);
      }
      const svgData = await response.text();
      
      // Parse and prepare SVG
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgData, 'image/svg+xml');
      const svg = doc.documentElement;
      
      // Remove hardcoded dimensions to allow responsive scaling
      svg.removeAttribute('width');
      svg.removeAttribute('height');
      svg.classList.add('excalidraw-svg');
      
      // Preserve original colors - no color replacement
      // Dark mode is handled via CSS filter inversion
      
      const modifiedSvg = new XMLSerializer().serializeToString(svg);
      container.innerHTML = modifiedSvg;
      container.dataset.loaded = 'true';
    } catch (error) {
      console.error('Error loading Excalidraw diagram:', error);
      const placeholder = container.querySelector('.excalidraw-placeholder');
      if (placeholder) {
        placeholder.innerHTML = '<span>Diagram unavailable</span>';
      }
    }
  }

  function initExcalidrawDiagrams() {
    const containers = document.querySelectorAll<HTMLElement>(
      '.excalidraw-container[data-lazy="true"]'
    );

    if (!containers.length) return;

    // Use IntersectionObserver to lazy load diagrams near the viewport
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const container = entry.target as HTMLElement;
            loadDiagram(container);
            // Stop observing once triggered - no need to re-fire
            observer.unobserve(container);
          }
        });
      },
      {
        // Start loading 200px before diagram enters viewport
        rootMargin: '200px 0px',
        threshold: 0,
      }
    );

    containers.forEach(container => {
      // Reset loaded state on page transitions
      container.dataset.loaded = 'false';
      observer.observe(container);
    });
  }
  
  // Run on initial page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initExcalidrawDiagrams);
  } else {
    initExcalidrawDiagrams();
  }
  
  // Run on Astro page transitions
  document.addEventListener('astro:page-load', initExcalidrawDiagrams);
</script>

<style>
  .excalidraw-figure {
    margin: 2rem auto;
    padding: 1rem;
    border: 2px solid var(--nr-border-color);
    background: var(--color-base-100);
    box-shadow: var(--nr-shadow-sm);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: min-content;
    max-width: 100%;
  }

  .excalidraw-container {
    width: max-content;
    max-width: 100%;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: fit-content;
    /* Light mode: no filter applied */
  }

  /* Dark mode: invert light colors to dark, rotate hue to restore color balance */
  :global([data-theme="neobrutalism-dark"]) .excalidraw-container {
    filter: invert(93%) hue-rotate(180deg);
  }

  /* Placeholder shown while diagram is off-screen or loading */
  .excalidraw-placeholder {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 2rem;
    color: color-mix(in oklab, var(--color-base-content) 40%, #0000);
    font-size: 0.875rem;
    /* height is set inline to match container - prevents CLS */
    justify-content: center;
  }

  .excalidraw-placeholder svg {
    width: 32px;
    height: 32px;
    opacity: 0.4;
  }
  
  .excalidraw-container :global(svg) {
    /* Stretch to fill container height, maintain aspect ratio */
    height: 100%;
    width: auto;
    max-width: 100%;
    max-height: 100%;
    display: block;
  }
  
  .excalidraw-caption {
    margin-top: 1rem;
    font-size: 0.875rem;
    color: var(--color-base-content);
    text-align: center;
    font-style: italic;
  }
</style>