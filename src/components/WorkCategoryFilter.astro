---
/**
 * WorkCategoryFilter.astro
 * 
 * A horizontally-scrollable filter bar for work project categories.
 * 
 * ## Key Features:
 * - Full viewport width container with edge-to-edge scroll
 * - Dynamic fade effects on both edges when content overflows
 * - Smooth hover effects without layout shifts
 * - Proper Astro View Transition integration with transition:persist
 * 
 * ============================================================================
 * VIEW TRANSITION ARCHITECTURE
 * ============================================================================
 * 
 * This component uses a hybrid approach combining transition:persist for
 * stability with CSS animations for visual polish.
 * 
 * ## The transition:persist Pattern
 * 
 * The parent container has `transition:persist` which tells Astro to:
 * 1. Keep the DOM element in place during page navigation
 * 2. NOT create view transition snapshots of it
 * 3. Update its contents via JavaScript after navigation
 * 
 * This is ideal for interactive elements that need to maintain scroll position
 * and respond quickly to navigation without visual disruption.
 * 
 * ## Animation Timeline: Work Details → Work/Category Listing
 * 
 * When navigating BACK from a work detail page to the listing:
 * 
 * t=0ms     │ View transition starts
 *           │ • Old page snapshot captured
 *           │ • work-card morphs from expanded → card position
 *           │ • Filter bar container starts appearing (opacity: 0)
 *           │
 * t=0-350ms │ Card morph animation
 *           │ • work-img, work-title, etc scale down from detail to card
 *           │ • Uses cubic-bezier(0.32, 0.72, 0, 1) for smooth deceleration
 *           │ • Filter bar remains invisible during this phase
 *           │
 * t=350ms   │ Card morph complete, filter bar fade begins
 *           │ • filter-bar-delayed-fade-in animation starts
 *           │ • Filter fade overlays also begin fading in
 *           │
 * t=350-650ms │ Filter bar fade-in
 *           │ • 0.3s ease-out animation from opacity 0 → 1
 *           │
 * t=650ms   │ All animations complete
 *           │ • Active button state updated via JS (astro:after-swap)
 *           │ • Scroll position restored
 * 
 * ## Animation Timeline: Work/Category Listing → Work Details
 * 
 * When navigating FORWARD to a work detail page:
 * 
 * t=0ms     │ User clicks card, view transition starts
 *           │ • JIT naming: clicked card gets transition names via JS
 *           │ • Filter bar starts fading out immediately
 *           │
 * t=0-150ms │ Filter bar quick fade-out
 *           │ • Disappears before card reaches its expanded position
 *           │ • Clears visual space for the morphing card
 *           │
 * t=0-350ms │ Card morph animation
 *           │ • work-img, work-title, etc scale up from card to detail
 *           │ • Card transition has z-index: 100 (above filter bar)
 *           │
 * t=350ms   │ All animations complete
 *           │ • Detail page fully visible
 * 
 * ## Z-Index Hierarchy During Transitions
 * 
 * Layer 100: work-card, work-img, work-body, work-title, work-impact
 *            → Morphing card elements always on top
 * 
 * Layer 10:  work-category-filter-container, filter-fade-left, filter-fade-right
 *            → Filter bar below morphing cards
 * 
 * Layer 2:   Named view transition groups (browser default)
 * 
 * Layer 0:   Root snapshot (::view-transition-group(root))
 * 
 * ## Key Astro Attributes Used:
 * 
 * - `transition:persist` - Element survives navigation, not snapshotted
 * - `transition:name` - Gives element identity for CSS targeting
 * - `transition:animate="none"` - Disables default Astro morph animation
 * 
 * ## JavaScript Integration:
 * 
 * The astro:after-swap event updates the persisted element:
 * - Updates active button styling based on new URL
 * - Restores horizontal scroll position
 * - Triggers fade overlay visibility check
 * 
 * @see https://docs.astro.build/en/guides/view-transitions/#transition-persist
 * @see src/styles/global.css (WORK CARD VIEW TRANSITIONS section)
 */
export interface Props {
  /** All available categories (sorted alphabetically) */
  categories: string[];
  /** Currently active category (null for "all projects" view) */
  activeCategory?: string | null;
}

const { categories, activeCategory = null } = Astro.props;

// Helper to create URL-safe slugs from category names
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');
}

function getCategoryUrl(cat: string): string {
  return `/work/category/${slugify(cat)}`;
}

const isAllActive = activeCategory === null;
---

<!-- 
  FILTER BAR CONTAINER
  ====================
  Uses w-screen + left-1/2 + -translate-x-1/2 to break out of parent container
  and span full viewport width. This allows fade effects to reach viewport edges.
  
  On larger screens (lg+), the nav content aligns with the project grid by using
  a container constraint that matches the grid's positioning.
-->
<div 
  class="relative mb-8 sm:mb-12 w-screen left-1/2 -translate-x-1/2" 
  id="work-category-filter-container"
  transition:name="work-category-filter-container"
  transition:animate="none" 
  transition:persist
>
  <!-- 
    LEFT FADE OVERLAY
    =================
    - Starts hidden (opacity-0), shown via JS when scrolled past start
    - transition:name prevents default fade-in animation during page nav
    - transition:animate="none" ensures instant appearance
  -->
  <div 
    id="filter-fade-left"
    class="absolute left-0 h-12 top-1/2 -translate-y-1/2 w-12 bg-gradient-to-r from-base-100 to-transparent pointer-events-none z-10 opacity-0"
    transition:name="filter-fade-left"
    transition:animate="none"
  ></div>
  
  <!-- 
    SCROLLABLE NAV
    ==============
    - gap-3: Extra gap prevents neobrutalist shadow overlaps
    - scroll-px-*: Ensures snap-scroll respects padding
    - scrollbar-hide: Custom utility to hide scrollbar
    - hover-lift-stable: Custom class for layout-stable hover effects
    
    Responsive padding strategy:
    - Mobile (default): px-2 - minimal padding for full-width scroll
    - Tablet (sm): px-4 - slightly more padding
    - Desktop (lg+): Uses mx-auto max-w-6xl px-4 to create a container that aligns
      the filter content with the grid below (which uses max-w-5xl mx-auto)
  -->
  <nav 
    id="work-category-nav"
    class="
      flex flex-nowrap gap-3 min-w-0 overflow-x-auto py-2 scrollbar-hide overscroll-contain
      justify-start px-2 scroll-px-2
      sm:px-4 sm:scroll-px-4
      lg:mx-auto lg:max-w-6xl lg:px-4 lg:scroll-px-4
    " 
  >
    <a 
      href="/work"
      class={`btn btn-sm font-semibold text-xs uppercase tracking-wider flex-shrink-0 hover-lift-stable ${isAllActive ? 'btn-accent' : 'btn-outline'}`}
      aria-current={isAllActive ? 'page' : undefined}
    >
      ALL PROJECTS
    </a>
    {categories.map((category) => (
      <a 
        href={getCategoryUrl(category)}
        class={`btn btn-sm font-semibold text-xs uppercase tracking-wider flex-shrink-0 hover-lift-stable ${category === activeCategory ? 'btn-accent' : 'btn-outline'}`}
        aria-current={category === activeCategory ? 'page' : undefined}
      >
        {category}
      </a>
    ))}
  </nav>
  
  <!-- 
    RIGHT FADE OVERLAY
    ==================
    - Starts visible (opacity-100) since there's usually overflow
    - JS updates based on actual scroll state
  -->
  <div 
    id="filter-fade-right"
    class="absolute right-0 h-12 top-1/2 -translate-y-1/2 w-12 bg-gradient-to-l from-base-100 to-transparent pointer-events-none z-10 opacity-100"
    transition:name="filter-fade-right"
    transition:animate="none"
  ></div>
</div>

<script>
  /**
   * Sets up the filter bar's interactive features:
   * - Fade visibility based on scroll position
   * - Auto-scroll active filter into view
   * - Horizontal scroll from vertical mouse wheel
   * - Resize handling
   * 
   * @param useSmooth - If true, scrolls to active filter with smooth animation
   */
  function setupFilterBar(useSmooth = false) {
    const nav = document.getElementById('work-category-nav');
    const container = document.getElementById('work-category-filter-container');
    const fadeLeft = document.getElementById('filter-fade-left');
    const fadeRight = document.getElementById('filter-fade-right');
    
    if (!nav || !container || !fadeLeft || !fadeRight) return;

    /**
     * Updates fade overlay visibility based on current scroll position.
     * - Left fade: visible when scrolled past start
     * - Right fade: visible when more content to scroll
     * - Both hidden when no overflow
     */
    function updateFades() {
      const scrollLeft = nav.scrollLeft;
      const scrollWidth = nav.scrollWidth;
      const clientWidth = nav.clientWidth;
      const maxScroll = scrollWidth - clientWidth;
      
      // No overflow - hide both fades
      if (maxScroll <= 0) {
        fadeLeft.style.opacity = '0';
        fadeRight.style.opacity = '0';
        return;
      }
      
      // Show left fade if scrolled past the start (5px threshold)
      fadeLeft.style.opacity = scrollLeft > 5 ? '1' : '0';
      
      // Show right fade if there's more content to scroll
      fadeRight.style.opacity = scrollLeft < maxScroll - 5 ? '1' : '0';
    }

    /**
     * Calculates scroll position for the filter bar.
     * 
     * Math:
     * - anchorPosition = first filter's offsetLeft (where ALL PROJECTS sits)
     * - targetScroll = activeFilterOffset - anchorPosition - peekOffset
     * - Clamp to [0, maxScroll]
     * - Skip if within threshold of current position
     * 
     * @see /src/utils/filterScrollUtils.ts for tested standalone version
     */
    function scrollActiveIntoView(smooth = true) {
      const activeLink = nav.querySelector('.btn-accent') as HTMLElement;
      const firstFilter = nav.querySelector('a') as HTMLElement;
      if (!activeLink || !firstFilter) return;
      
      // Constants
      const PEEK_OFFSET = 40;  // Show ~40px of previous filter for easy clicking
      const THRESHOLD = 10;   // Skip scrolling if within this many pixels
      
      // Measurements
      const maxScroll = Math.max(0, nav.scrollWidth - nav.clientWidth);
      const currentScroll = nav.scrollLeft;
      const containerPadding = parseFloat(getComputedStyle(nav).paddingLeft) || 0;
      const activePosition = activeLink.offsetLeft;
      const firstFilterPosition = firstFilter.offsetLeft;
      
      // No overflow - nothing to scroll
      if (maxScroll === 0) {
        requestAnimationFrame(updateFades);
        return;
      }
      
      // If first filter is active, align to left edge (no peek needed)
      // Otherwise, add peek offset so user can easily click previous filter
      const isFirstActive = activePosition <= firstFilterPosition;
      let targetScroll: number;
      
      if (isFirstActive) {
        targetScroll = 0;
      } else {
        // Position with peek offset to show part of previous filter
        targetScroll = activePosition - containerPadding - PEEK_OFFSET;
      }
      
      // Clamp to valid range
      targetScroll = Math.max(0, Math.min(targetScroll, maxScroll));
      
      // Skip if already at or near target position
      const difference = Math.abs(currentScroll - targetScroll);
      
      // Special case: if both are at or near maxScroll, skip (no more room to scroll)
      const bothAtMax = currentScroll >= maxScroll - 5 && targetScroll >= maxScroll - 5;
      
      if (difference < THRESHOLD || bothAtMax) {
        requestAnimationFrame(updateFades);
        return;
      }
      
      // Apply scroll
      nav.scrollTo({
        left: targetScroll,
        behavior: smooth ? 'smooth' : 'instant'
      });
      
      requestAnimationFrame(updateFades);
    }

    // Initial setup - set fades and scroll to active
    updateFades();
    scrollActiveIntoView(useSmooth);

    // Update fades on scroll
    nav.addEventListener('scroll', updateFades, { passive: true });

    // Re-check on resize (debounced to 100ms)
    let resizeTimeout: ReturnType<typeof setTimeout>;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        scrollActiveIntoView(false);
        updateFades();
      }, 100);
    });

    // Native horizontal scrolling is used:
    // - Trackpads: horizontal swipe
    // - Mice: Shift+scroll or horizontal wheel
    // - Touch: horizontal swipe
  }

  // === ASTRO VIEW TRANSITION LIFECYCLE ===
  // 
  // Event order during navigation:
  // 1. astro:before-preparation - Before new page fetched
  // 2. astro:after-preparation - New page loaded, before swap
  // 3. astro:before-swap - Just before DOM replacement
  // 4. astro:after-swap - DOM replaced, BEFORE visible to user ← Fades set here
  // 5. astro:page-load - Page fully loaded and visible ← Smooth scroll here (if filter changed)
  //
  // Strategy:
  // - Use sessionStorage to track previous filter (survives view transitions)
  // - astro:after-swap: Set fade visibility instantly (before page visible)
  // - astro:page-load: Smooth scroll only if active filter changed
  
  const PREV_FILTER_KEY = 'workCategoryFilterPrevActive';
  const SCROLL_POSITION_KEY = 'workCategoryFilterScrollPos';
  const PAGE_SCROLL_KEY = 'workPageVerticalScroll';
  
  // Get current active filter href
  function getActiveFilterHref(): string | null {
    return document.querySelector('#work-category-nav .btn-accent')?.getAttribute('href') || null;
  }
  
  // Save current scroll positions (horizontal filter bar + vertical page)
  function saveScrollPositions() {
    const nav = document.getElementById('work-category-nav');
    if (nav) {
      sessionStorage.setItem(SCROLL_POSITION_KEY, String(nav.scrollLeft));
    }
    // Save vertical page scroll for work pages
    sessionStorage.setItem(PAGE_SCROLL_KEY, String(window.scrollY));
  }
  
  // Initial page load - instant scroll, set fades
  setupFilterBar(false);
  sessionStorage.setItem(PREV_FILTER_KEY, getActiveFilterHref() || '');
  
  // Before navigation starts - save current scroll positions
  document.addEventListener('astro:before-preparation', saveScrollPositions);
  
  // Track clicked button href to maintain hover state across DOM swap
  const CLICKED_BTN_KEY = 'workFilterClickedHref';
  
  // Handle filter button clicks: save scroll positions + add click animation + lock hover
  document.getElementById('work-category-nav')?.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    const link = target.closest('a') as HTMLElement | null;
    
    if (link) {
      saveScrollPositions();
      
      // Mark this as a filter-to-filter navigation (for scroll restoration)
      sessionStorage.setItem('workFilterNavigation', 'true');
      
      // Store clicked button href to re-apply hover lock after DOM swap
      const href = link.getAttribute('href');
      if (href) {
        sessionStorage.setItem(CLICKED_BTN_KEY, href);
      }
      
      // Lock hover state during transition
      link.classList.add('filter-btn-clicked');
      
      // Add pulse animation for visual feedback
      link.classList.add('filter-btn-animate');
      // Remove animation class after animation completes
      link.addEventListener('animationend', () => {
        link.classList.remove('filter-btn-animate');
      }, { once: true });
    }
  });
  
  // Remove hover-lock after page transition completes (with delay for mouse position check)
  document.addEventListener('astro:page-load', () => {
    const clickedHref = sessionStorage.getItem(CLICKED_BTN_KEY);
    if (clickedHref) {
      sessionStorage.removeItem(CLICKED_BTN_KEY);
      
      // Delay to allow transition animation to complete and hover state to re-evaluate
      setTimeout(() => {
        const nav = document.getElementById('work-category-nav');
        const btn = nav?.querySelector(`a[href="${clickedHref}"]`);
        if (btn) {
          btn.classList.remove('filter-btn-clicked');
        }
      }, 300); // 300ms matches typical view transition duration
    }
  });
  
  // After view transition swap - update persisted nav state and restore scroll
  document.addEventListener('astro:after-swap', () => {
    const nav = document.getElementById('work-category-nav');
    const fadeLeft = document.getElementById('filter-fade-left');
    const fadeRight = document.getElementById('filter-fade-right');
    
    if (!nav || !fadeLeft || !fadeRight) return;
    
    // Since nav is persisted, we need to update active button styling based on current URL
    const currentPath = window.location.pathname.replace(/\/$/, ''); // Normalize: remove trailing slash
    const buttons = nav.querySelectorAll('a');
    
    buttons.forEach(btn => {
      const href = (btn.getAttribute('href') || '').replace(/\/$/, ''); // Normalize href too
      
      // Match: exact path OR /work matches /work OR category URLs match
      const isActive = href === currentPath;
      
      if (isActive) {
        btn.classList.remove('btn-outline');
        btn.classList.add('btn-accent');
        btn.setAttribute('aria-current', 'page');
      } else {
        btn.classList.remove('btn-accent');
        btn.classList.add('btn-outline');
        btn.removeAttribute('aria-current');
      }
    });
    
    // Check if this is a filter-to-filter navigation (flag was set on click)
    const isFilterNavigation = sessionStorage.getItem('workFilterNavigation') === 'true';
    sessionStorage.removeItem('workFilterNavigation'); // Clear the flag
    
    // Always restore horizontal filter bar scroll (prevents animation from 0)
    const savedScroll = sessionStorage.getItem(SCROLL_POSITION_KEY);
    if (savedScroll !== null) {
      nav.scrollLeft = parseInt(savedScroll, 10);
    }
    
    // Only restore vertical page scroll for filter-to-filter navigation
    // (let browser handle back-button scroll restoration)
    if (isFilterNavigation) {
      const savedPageScroll = sessionStorage.getItem(PAGE_SCROLL_KEY);
      if (savedPageScroll !== null) {
        window.scrollTo(0, parseInt(savedPageScroll, 10));
      }
    }
    
    // Update fades based on current scroll position
    const scrollLeft = nav.scrollLeft;
    const maxScroll = nav.scrollWidth - nav.clientWidth;
    
    if (maxScroll <= 0) {
      fadeLeft.style.opacity = '0';
      fadeRight.style.opacity = '0';
    } else {
      fadeLeft.style.opacity = scrollLeft > 5 ? '1' : '0';
      fadeRight.style.opacity = scrollLeft < maxScroll - 5 ? '1' : '0';
    }
  });
  
  // After page is visible - smooth scroll to active filter if changed + card animations
  document.addEventListener('astro:page-load', () => {
    requestAnimationFrame(() => {
      const currentActiveHref = getActiveFilterHref();
      const previousActiveHref = sessionStorage.getItem(PREV_FILTER_KEY);
      
      // Only animate scroll if the active filter actually changed
      const filterChanged = currentActiveHref !== previousActiveHref;
      setupFilterBar(filterChanged); // true = smooth scroll, false = instant
      
      // Animate cards if this was a filter navigation
      if (filterChanged && sessionStorage.getItem('triggerCardAnimation') === 'true') {
        sessionStorage.removeItem('triggerCardAnimation');
        
        // Add entrance animation to all work cards
        const cards = document.querySelectorAll('[data-work-card]');
        cards.forEach((card, index) => {
          // Stagger the animations slightly
          setTimeout(() => {
            card.classList.add('card-entering');
            card.addEventListener('animationend', () => {
              card.classList.remove('card-entering');
            }, { once: true });
          }, index * 50); // 50ms stagger between cards
        });
      }
      
      // Update stored value
      sessionStorage.setItem(PREV_FILTER_KEY, currentActiveHref || '');
    });
  });
</script>
