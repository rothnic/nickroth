---
/**
 * WorkCategoryFilter.astro
 * 
 * A horizontally-scrollable filter bar for work project categories.
 * 
 * ## Key Features:
 * - Full viewport width container with edge-to-edge scroll
 * - Dynamic fade effects on both edges when content overflows
 * - Smooth hover effects without layout shifts
 * - Proper Astro View Transition integration
 * 
 * ## View Transition Patterns (Important!):
 * 
 * When using Astro View Transitions with elements that need immediate visibility
 * (like these fade overlays), you must handle the transition lifecycle carefully:
 * 
 * 1. **transition:animate="none"** - Prevents Astro from animating the element
 *    during page transitions. Without this, new elements fade in by default.
 * 
 * 2. **transition:name="unique-name"** - Gives the element a stable identity
 *    across page navigations. Elements with matching names "morph" instead of
 *    fading in/out.
 * 
 * 3. **astro:after-swap event** - Fires AFTER DOM swap but BEFORE the page
 *    becomes visible. Use this to set initial state for elements that need
 *    to appear immediately (not astro:page-load which fires after visible).
 * 
 * ## Layout Stability Patterns:
 * 
 * 1. **hover-lift-stable class** - Provides visual hover feedback using only
 *    CSS transform (which doesn't affect document flow), preventing layout
 *    shifts to sibling elements.
 * 
 * 2. **w-screen left-1/2 -translate-x-1/2** - CSS pattern to break an element
 *    out of its container to full viewport width.
 * 
 * 3. **scroll-px-* classes** - Tailwind's scroll-padding utilities ensure
 *    snap-scrolling respects container padding.
 * 
 * @see https://docs.astro.build/en/guides/view-transitions/#lifecycle-events
 * @see /docs/patterns/view-transitions.md
 */
export interface Props {
  /** All available categories (sorted alphabetically) */
  categories: string[];
  /** Currently active category (null for "all projects" view) */
  activeCategory?: string | null;
}

const { categories, activeCategory = null } = Astro.props;

// Helper to create URL-safe slugs from category names
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');
}

function getCategoryUrl(cat: string): string {
  return `/work/category/${slugify(cat)}`;
}

const isAllActive = activeCategory === null;
---

<!-- 
  FILTER BAR CONTAINER
  ====================
  Uses w-screen + left-1/2 + -translate-x-1/2 to break out of parent container
  and span full viewport width. This allows fade effects to reach viewport edges.
-->
<div 
  class="relative mb-8 sm:mb-12 w-screen left-1/2 -translate-x-1/2" 
  id="work-category-filter-container"
>
  <!-- 
    LEFT FADE OVERLAY
    =================
    - Starts hidden (opacity-0), shown via JS when scrolled past start
    - transition:name prevents default fade-in animation during page nav
    - transition:animate="none" ensures instant appearance
  -->
  <div 
    id="filter-fade-left"
    class="absolute left-0 h-12 top-1/2 -translate-y-1/2 w-12 bg-gradient-to-r from-base-100 to-transparent pointer-events-none z-10 opacity-0"
    transition:name="filter-fade-left"
    transition:animate="none"
  ></div>
  
  <!-- 
    SCROLLABLE NAV
    ==============
    - gap-3: Extra gap prevents neobrutalist shadow overlaps
    - scroll-px-*: Ensures snap-scroll respects padding
    - scrollbar-hide: Custom utility to hide scrollbar
    - hover-lift-stable: Custom class for layout-stable hover effects
  -->
  <nav 
    class="
      flex flex-nowrap gap-3 min-w-0 overflow-x-auto py-2 scrollbar-hide overscroll-contain
      justify-start px-2 scroll-px-2
      sm:px-4 sm:scroll-px-4
      xl:justify-center
    " 
    transition:name="work-category-nav"
    transition:persist
    id="work-category-nav"
  >
    <a 
      href="/work"
      class={`btn btn-sm font-semibold text-xs uppercase tracking-wider flex-shrink-0 hover-lift-stable ${isAllActive ? 'btn-accent' : 'btn-outline'}`}
      aria-current={isAllActive ? 'page' : undefined}
    >
      ALL PROJECTS
    </a>
    {categories.map((category) => (
      <a 
        href={getCategoryUrl(category)}
        class={`btn btn-sm font-semibold text-xs uppercase tracking-wider flex-shrink-0 hover-lift-stable ${category === activeCategory ? 'btn-accent' : 'btn-outline'}`}
        aria-current={category === activeCategory ? 'page' : undefined}
      >
        {category}
      </a>
    ))}
  </nav>
  
  <!-- 
    RIGHT FADE OVERLAY
    ==================
    - Starts visible (opacity-100) since there's usually overflow
    - JS updates based on actual scroll state
  -->
  <div 
    id="filter-fade-right"
    class="absolute right-0 h-12 top-1/2 -translate-y-1/2 w-12 bg-gradient-to-l from-base-100 to-transparent pointer-events-none z-10 opacity-100"
    transition:name="filter-fade-right"
    transition:animate="none"
  ></div>
</div>

<script>
  /**
   * Sets up the filter bar's interactive features:
   * - Fade visibility based on scroll position
   * - Auto-scroll active filter into view
   * - Horizontal scroll from vertical mouse wheel
   * - Resize handling
   * 
   * @param useSmooth - If true, scrolls to active filter with smooth animation
   */
  function setupFilterBar(useSmooth = false) {
    const nav = document.getElementById('work-category-nav');
    const container = document.getElementById('work-category-filter-container');
    const fadeLeft = document.getElementById('filter-fade-left');
    const fadeRight = document.getElementById('filter-fade-right');
    
    if (!nav || !container || !fadeLeft || !fadeRight) return;

    /**
     * Updates fade overlay visibility based on current scroll position.
     * - Left fade: visible when scrolled past start
     * - Right fade: visible when more content to scroll
     * - Both hidden when no overflow
     */
    function updateFades() {
      const scrollLeft = nav.scrollLeft;
      const scrollWidth = nav.scrollWidth;
      const clientWidth = nav.clientWidth;
      const maxScroll = scrollWidth - clientWidth;
      
      // No overflow - hide both fades
      if (maxScroll <= 0) {
        fadeLeft.style.opacity = '0';
        fadeRight.style.opacity = '0';
        return;
      }
      
      // Show left fade if scrolled past the start (5px threshold)
      fadeLeft.style.opacity = scrollLeft > 5 ? '1' : '0';
      
      // Show right fade if there's more content to scroll
      fadeRight.style.opacity = scrollLeft < maxScroll - 5 ? '1' : '0';
    }

    /**
     * Calculates scroll position for the filter bar.
     * 
     * Math:
     * - anchorPosition = first filter's offsetLeft (where ALL PROJECTS sits)
     * - targetScroll = activeFilterOffset - anchorPosition - peekOffset
     * - Clamp to [0, maxScroll]
     * - Skip if within threshold of current position
     * 
     * @see /src/utils/filterScrollUtils.ts for tested standalone version
     */
    function scrollActiveIntoView(smooth = true) {
      const activeLink = nav.querySelector('.btn-accent') as HTMLElement;
      const firstFilter = nav.querySelector('a') as HTMLElement;
      if (!activeLink || !firstFilter) return;
      
      // Constants
      const PEEK_OFFSET = 30;  // Show ~30px of previous filter
      const THRESHOLD = 10;   // Skip scrolling if within this many pixels
      
      // Measurements
      const maxScroll = Math.max(0, nav.scrollWidth - nav.clientWidth);
      const currentScroll = nav.scrollLeft;
      const anchorPosition = firstFilter.offsetLeft;
      const activePosition = activeLink.offsetLeft;
      
      // No overflow - nothing to scroll
      if (maxScroll === 0) {
        requestAnimationFrame(updateFades);
        return;
      }
      
      // Special case: first filter is active - scroll to start
      if (activePosition <= anchorPosition) {
        if (currentScroll < THRESHOLD) {
          // Already at start, skip
          requestAnimationFrame(updateFades);
          return;
        }
        nav.scrollTo({ left: 0, behavior: smooth ? 'smooth' : 'instant' });
        requestAnimationFrame(updateFades);
        return;
      }
      
      // Calculate target: position active filter at anchor, with peek offset
      let targetScroll = activePosition - anchorPosition - PEEK_OFFSET;
      
      // Clamp to valid range
      targetScroll = Math.max(0, Math.min(targetScroll, maxScroll));
      
      // Skip if already at or near target position (increased threshold for smoother UX)
      const difference = Math.abs(currentScroll - targetScroll);
      
      // Special case: if both are at or near maxScroll, skip (no more room to scroll)
      const bothAtMax = currentScroll >= maxScroll - 5 && targetScroll >= maxScroll - 5;
      
      if (difference < THRESHOLD || bothAtMax) {
        requestAnimationFrame(updateFades);
        return;
      }
      
      // Apply scroll
      nav.scrollTo({
        left: targetScroll,
        behavior: smooth ? 'smooth' : 'instant'
      });
      
      requestAnimationFrame(updateFades);
    }

    // Initial setup - set fades and scroll to active
    updateFades();
    scrollActiveIntoView(useSmooth);

    // Update fades on scroll
    nav.addEventListener('scroll', updateFades, { passive: true });

    // Re-check on resize (debounced to 100ms)
    let resizeTimeout: ReturnType<typeof setTimeout>;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        scrollActiveIntoView(false);
        updateFades();
      }, 100);
    });

    /**
     * Converts vertical mouse wheel to horizontal scroll.
     * Capped at 80px per event for smoother scrolling on trackpads.
     */
    nav.addEventListener('wheel', (e) => {
      if (e.deltaY !== 0) {
        e.preventDefault();
        const scrollAmount = Math.sign(e.deltaY) * Math.min(Math.abs(e.deltaY), 80);
        nav.scrollLeft += scrollAmount;
      }
    }, { passive: false });
  }

  // === ASTRO VIEW TRANSITION LIFECYCLE ===
  // 
  // Event order during navigation:
  // 1. astro:before-preparation - Before new page fetched
  // 2. astro:after-preparation - New page loaded, before swap
  // 3. astro:before-swap - Just before DOM replacement
  // 4. astro:after-swap - DOM replaced, BEFORE visible to user ← Fades set here
  // 5. astro:page-load - Page fully loaded and visible ← Smooth scroll here (if filter changed)
  //
  // Strategy:
  // - Use sessionStorage to track previous filter (survives view transitions)
  // - astro:after-swap: Set fade visibility instantly (before page visible)
  // - astro:page-load: Smooth scroll only if active filter changed
  
  const PREV_FILTER_KEY = 'workCategoryFilterPrevActive';
  const SCROLL_POSITION_KEY = 'workCategoryFilterScrollPos';
  const PAGE_SCROLL_KEY = 'workPageVerticalScroll';
  
  // Get current active filter href
  function getActiveFilterHref(): string | null {
    return document.querySelector('#work-category-nav .btn-accent')?.getAttribute('href') || null;
  }
  
  // Save current scroll positions (horizontal filter bar + vertical page)
  function saveScrollPositions() {
    const nav = document.getElementById('work-category-nav');
    if (nav) {
      sessionStorage.setItem(SCROLL_POSITION_KEY, String(nav.scrollLeft));
    }
    // Save vertical page scroll for work pages
    sessionStorage.setItem(PAGE_SCROLL_KEY, String(window.scrollY));
  }
  
  // Initial page load - instant scroll, set fades
  setupFilterBar(false);
  sessionStorage.setItem(PREV_FILTER_KEY, getActiveFilterHref() || '');
  
  // Before navigation starts - save current scroll positions
  document.addEventListener('astro:before-preparation', saveScrollPositions);
  
  // Track clicked button href to maintain hover state across DOM swap
  const CLICKED_BTN_KEY = 'workFilterClickedHref';
  
  // Handle filter button clicks: save scroll positions + add click animation + lock hover
  document.getElementById('work-category-nav')?.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    const link = target.closest('a') as HTMLElement | null;
    
    if (link) {
      saveScrollPositions();
      
      // Mark this as a filter-to-filter navigation (for scroll restoration)
      sessionStorage.setItem('workFilterNavigation', 'true');
      
      // Store clicked button href to re-apply hover lock after DOM swap
      const href = link.getAttribute('href');
      if (href) {
        sessionStorage.setItem(CLICKED_BTN_KEY, href);
      }
      
      // Lock hover state during transition
      link.classList.add('filter-btn-clicked');
      
      // Add pulse animation for visual feedback
      link.classList.add('filter-btn-animate');
      // Remove animation class after animation completes
      link.addEventListener('animationend', () => {
        link.classList.remove('filter-btn-animate');
      }, { once: true });
    }
  });
  
  // Remove hover-lock after page transition completes (with delay for mouse position check)
  document.addEventListener('astro:page-load', () => {
    const clickedHref = sessionStorage.getItem(CLICKED_BTN_KEY);
    if (clickedHref) {
      sessionStorage.removeItem(CLICKED_BTN_KEY);
      
      // Delay to allow transition animation to complete and hover state to re-evaluate
      setTimeout(() => {
        const nav = document.getElementById('work-category-nav');
        const btn = nav?.querySelector(`a[href="${clickedHref}"]`);
        if (btn) {
          btn.classList.remove('filter-btn-clicked');
        }
      }, 300); // 300ms matches typical view transition duration
    }
  });
  
  // After view transition swap - update persisted nav state and restore scroll
  document.addEventListener('astro:after-swap', () => {
    const nav = document.getElementById('work-category-nav');
    const fadeLeft = document.getElementById('filter-fade-left');
    const fadeRight = document.getElementById('filter-fade-right');
    
    if (!nav || !fadeLeft || !fadeRight) return;
    
    // Since nav is persisted, we need to update active button styling based on current URL
    const currentPath = window.location.pathname;
    const buttons = nav.querySelectorAll('a');
    
    buttons.forEach(btn => {
      const href = btn.getAttribute('href');
      const isActive = href === currentPath || 
        (currentPath === '/work' && href === '/work') ||
        (currentPath.startsWith('/work/category/') && href === currentPath);
      
      if (isActive) {
        btn.classList.remove('btn-outline');
        btn.classList.add('btn-accent');
        btn.setAttribute('aria-current', 'page');
      } else {
        btn.classList.remove('btn-accent');
        btn.classList.add('btn-outline');
        btn.removeAttribute('aria-current');
      }
    });
    
    // Check if this is a filter-to-filter navigation (flag was set on click)
    const isFilterNavigation = sessionStorage.getItem('workFilterNavigation') === 'true';
    sessionStorage.removeItem('workFilterNavigation'); // Clear the flag
    
    // Always restore horizontal filter bar scroll (prevents animation from 0)
    const savedScroll = sessionStorage.getItem(SCROLL_POSITION_KEY);
    if (savedScroll !== null) {
      nav.scrollLeft = parseInt(savedScroll, 10);
    }
    
    // Only restore vertical page scroll for filter-to-filter navigation
    // (let browser handle back-button scroll restoration)
    if (isFilterNavigation) {
      const savedPageScroll = sessionStorage.getItem(PAGE_SCROLL_KEY);
      if (savedPageScroll !== null) {
        window.scrollTo(0, parseInt(savedPageScroll, 10));
      }
    }
    
    // Update fades based on current scroll position
    const scrollLeft = nav.scrollLeft;
    const maxScroll = nav.scrollWidth - nav.clientWidth;
    
    if (maxScroll <= 0) {
      fadeLeft.style.opacity = '0';
      fadeRight.style.opacity = '0';
    } else {
      fadeLeft.style.opacity = scrollLeft > 5 ? '1' : '0';
      fadeRight.style.opacity = scrollLeft < maxScroll - 5 ? '1' : '0';
    }
  });
  
  // After page is visible - smooth scroll to active filter if changed + card animations
  document.addEventListener('astro:page-load', () => {
    requestAnimationFrame(() => {
      const currentActiveHref = getActiveFilterHref();
      const previousActiveHref = sessionStorage.getItem(PREV_FILTER_KEY);
      
      // Only animate scroll if the active filter actually changed
      const filterChanged = currentActiveHref !== previousActiveHref;
      setupFilterBar(filterChanged); // true = smooth scroll, false = instant
      
      // Animate cards if this was a filter navigation
      if (filterChanged && sessionStorage.getItem('triggerCardAnimation') === 'true') {
        sessionStorage.removeItem('triggerCardAnimation');
        
        // Add entrance animation to all work cards
        const cards = document.querySelectorAll('[data-work-card]');
        cards.forEach((card, index) => {
          // Stagger the animations slightly
          setTimeout(() => {
            card.classList.add('card-entering');
            card.addEventListener('animationend', () => {
              card.classList.remove('card-entering');
            }, { once: true });
          }, index * 50); // 50ms stagger between cards
        });
      }
      
      // Update stored value
      sessionStorage.setItem(PREV_FILTER_KEY, currentActiveHref || '');
    });
  });
</script>
