---
/**
 * OutlineBottomSheet Component
 * 
 * Mobile-only component that provides a sticky "Contents" button at the bottom-right
 * of the screen. When clicked, it expands into a bottom-sheet with the article outline.
 * 
 * This component is lazy-loaded using client:idle and is only rendered on work detail pages.
 * 
 * IMPORTANT: To avoid breaking view transitions on mobile, the fixed-positioned container
 * is NOT rendered initially. It's only added to the DOM after the user scrolls past 300px.
 * This prevents fixed elements from interfering with view transitions on mobile browsers.
 * 
 * Features:
 * - Minimal sticky tag at bottom-right (mobile only)
 * - Slides up as bottom-sheet when clicked
 * - Scrollable content if outline is taller than viewport
 * - Auto-minimizes after selecting a section
 * - Smooth scroll to selected section
 * - Lazy-rendered after scrolling to avoid view transition conflicts
 * 
 * Usage (in [slug].astro):
 * <OutlineBottomSheet client:idle />
 */

import ArticleOutline from './ArticleOutline.astro';
---

<!-- Template for mobile bottom sheet (will be rendered by JS after scroll) -->
<!-- Hidden on lg: screens where sidebar is visible -->
<template id="outline-bottom-sheet-template" class="lg:hidden">
  <div class="outline-bottom-sheet-container lg:hidden">
  <!-- Sticky trigger button -->
  <button 
    class="outline-trigger"
    aria-label="Open article outline"
    aria-expanded="false"
    aria-controls="outline-sheet"
  >
    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"></path>
    </svg>
    <span class="outline-trigger-text">Contents</span>
  </button>
  
  <!-- Backdrop overlay -->
  <div class="outline-backdrop" aria-hidden="true"></div>
  
  <!-- Bottom sheet panel -->
  <div 
    id="outline-sheet"
    class="outline-bottom-sheet"
    role="dialog"
    aria-label="Article contents"
    aria-modal="true"
  >
    <!-- Handle bar -->
    <div class="outline-sheet-handle" aria-hidden="true">
      <span class="handle-bar"></span>
    </div>
    
    <!-- Header -->
    <div class="outline-sheet-header">
      <h2 class="text-lg font-bold uppercase tracking-wide">Contents</h2>
      <button 
        class="outline-close"
        aria-label="Close outline"
      >
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>
    
    <!-- Scrollable content -->
    <div class="outline-sheet-content">
      <ArticleOutline class="outline-in-sheet" showHeading={false} />
    </div>
  </div>
</template>

<style>
  .outline-bottom-sheet-container {
    /* Container is always position fixed at the bottom */
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    pointer-events: none; /* Allow clicks through when closed */
  }
  
  /* Sticky trigger button */
  .outline-trigger {
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    z-index: 1001;
    pointer-events: auto;
    
    display: flex;
    align-items: center;
    gap: 0.375rem;
    
    padding: 0.625rem 0.875rem;
    background-color: var(--color-primary);
    color: white;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    
    border: 3px solid oklch(0.2 0 0);
    box-shadow: 4px 4px 0px 0px oklch(0.2 0 0);
    
    transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s ease, opacity 0.3s ease;
    
    /* Initially hidden */
    opacity: 0;
    pointer-events: none;
    transform: translateY(20px) scale(0.8);
  }
  
  /* Show when scrolled */
  .outline-bottom-sheet-container.scrolled .outline-trigger {
    opacity: 1;
    pointer-events: auto;
    transform: translateY(0) scale(1);
  }
  
  .outline-trigger:hover {
    transform: translate(-2px, -2px);
    box-shadow: 6px 6px 0px 0px oklch(0.2 0 0);
  }
  
  .outline-trigger:active {
    transform: translate(1px, 1px);
    box-shadow: 2px 2px 0px 0px oklch(0.2 0 0);
  }
  
  /* Hide trigger when sheet is open */
  .outline-bottom-sheet-container.open .outline-trigger {
    opacity: 0;
    pointer-events: none;
    transform: translateY(20px);
  }
  
  /* Backdrop overlay */
  .outline-backdrop {
    position: fixed;
    inset: 0;
    background-color: oklch(0.1 0 0 / 0.5);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.25s ease;
  }
  
  .outline-bottom-sheet-container.open .outline-backdrop {
    opacity: 1;
    pointer-events: auto;
  }
  
  /* Bottom sheet panel */
  .outline-bottom-sheet {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1002;
    pointer-events: auto;
    
    max-height: 70vh;
    min-height: 200px;
    
    background-color: var(--color-base-100);
    border-top: 4px solid oklch(0.2 0 0);
    border-left: 4px solid oklch(0.2 0 0);
    border-right: 4px solid oklch(0.2 0 0);
    border-top-left-radius: 1rem;
    border-top-right-radius: 1rem;
    
    box-shadow: 0 -8px 32px oklch(0.1 0 0 / 0.3);
    
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
    
    display: flex;
    flex-direction: column;
  }
  
  .outline-bottom-sheet-container.open .outline-bottom-sheet {
    transform: translateY(0);
  }
  
  /* Handle bar for touch affordance */
  .outline-sheet-handle {
    display: flex;
    justify-content: center;
    padding: 0.5rem 0;
    cursor: grab;
  }
  
  .handle-bar {
    width: 40px;
    height: 4px;
    background-color: oklch(0.7 0 0);
    border-radius: 2px;
  }
  
  /* Header */
  .outline-sheet-header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    padding: 0.25rem 0.75rem 0.75rem;
    border-bottom: 2px solid var(--color-base-300);
  }
  
  .outline-close {
    padding: 0.5rem;
    color: oklch(0.5 0 0);
    transition: color 0.15s ease;
  }
  
  .outline-close:hover {
    color: oklch(0.2 0 0);
  }
  
  /* Scrollable content area */
  .outline-sheet-content {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem 0.5rem 1.5rem;
    -webkit-overflow-scrolling: touch;
  }
  
  /* Safe area padding for notched phones */
  @supports (padding-bottom: env(safe-area-inset-bottom)) {
    .outline-sheet-content {
      padding-bottom: calc(1.5rem + env(safe-area-inset-bottom));
    }
  }
  
  /* Override some ArticleOutline styles inside sheet */
  .outline-in-sheet :global(h3) {
    display: none; /* Hide the "Contents" heading in sheet since we have header */
  }
  
  /* Dark mode */
  [data-theme="neobrutalism-dark"] .outline-trigger {
    border-color: oklch(0.4 0 0);
    box-shadow: 4px 4px 0px 0px oklch(0.4 0 0);
  }
  
  [data-theme="neobrutalism-dark"] .outline-trigger:hover {
    box-shadow: 6px 6px 0px 0px oklch(0.4 0 0);
  }
  
  [data-theme="neobrutalism-dark"] .outline-trigger:active {
    box-shadow: 2px 2px 0px 0px oklch(0.4 0 0);
  }
  
  [data-theme="neobrutalism-dark"] .outline-bottom-sheet {
    border-color: oklch(0.4 0 0);
    box-shadow: 0 -8px 32px oklch(0 0 0 / 0.5);
  }
  
  [data-theme="neobrutalism-dark"] .handle-bar {
    background-color: oklch(0.5 0 0);
  }
  
  [data-theme="neobrutalism-dark"] .outline-close:hover {
    color: oklch(0.85 0 0);
  }
</style>

<script>
  /**
   * Lazy-render and initialize bottom sheet interactions
   * 
   * To avoid breaking view transitions on mobile, we delay rendering the 
   * fixed-positioned container until after the user scrolls past 300px.
   */
  
  let containerRendered = false;
  let scrollListenerAdded = false;
  
  /**
   * Render the bottom sheet container from template
   */
  function renderBottomSheet() {
    if (containerRendered) return;
    
    const template = document.getElementById('outline-bottom-sheet-template') as HTMLTemplateElement;
    if (!template) return;
    
    // Clone and insert the template content
    const clone = template.content.cloneNode(true);
    document.body.appendChild(clone);
    containerRendered = true;
    
    // Initialize the newly rendered container
    initBottomSheet();
    
    // CRITICAL: Initialize the ArticleOutline inside the bottom sheet
    // The outline script runs on page load before this template is rendered,
    // so we need to manually trigger initialization for the newly added outline
    requestAnimationFrame(() => {
      const outlineInSheet = document.querySelector('.outline-bottom-sheet .article-outline:not(.initialized)');
      if (outlineInSheet) {
        // Dispatch a custom event that ArticleOutline can listen for
        const event = new CustomEvent('outline-container-added', { bubbles: true });
        outlineInSheet.dispatchEvent(event);
        
        // Set up click handlers for outline links AFTER they're created
        // Wait a bit for the outline to populate
        setTimeout(() => {
          setupOutlineLinkHandlers();
        }, 100);
      }
    });
  }
  
  /**
   * Setup click handlers for outline links in the bottom sheet
   * This must be called AFTER the ArticleOutline initializes and creates the links
   * 
   * For mobile: Close the sheet and let Astro's router handle the navigation.
   * The data-astro-history="replace" attribute ensures no history entries are created.
   */
  function setupOutlineLinkHandlers() {
    const container = document.querySelector('.outline-bottom-sheet-container');
    if (!container) return;
    
    const outlineLinks = container.querySelectorAll('[data-outline-link]');
    outlineLinks.forEach((link) => {
      link.addEventListener('click', async (e) => {
        // Don't prevent default - let Astro's router handle the navigation
        // Just close the sheet and unlock the body
        
        // Read scroll position BEFORE any DOM changes
        const bodyTop = document.body.style.top;
        const savedScrollY = bodyTop ? Math.abs(parseInt(bodyTop)) : window.scrollY;
        
        console.log('Mobile outline link clicked');
        console.log('Saved scroll position:', savedScrollY);
        
        // Close sheet UI
        container.classList.remove('open');
        const trigger = container.querySelector('.outline-trigger') as HTMLButtonElement;
        if (trigger) {
          trigger.setAttribute('aria-expanded', 'false');
        }
        
        // Unlock body and restore scroll position
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.left = '';
        document.body.style.right = '';
        document.body.style.overflow = '';
        
        // Restore scroll position immediately
        window.scrollTo(0, savedScrollY);
        
        console.log('Sheet closed, scroll restored to:', savedScrollY);
        
        // Let Astro's router handle the rest (it will navigate to the hash)
        // The link has data-astro-history="replace" so it won't create a history entry
      });
    });
  }
  
  /**
   * Scroll to heading based on URL hash
   * Called on page load and when using browser back/forward buttons
   */
  function scrollToHashIfPresent() {
    const hash = window.location.hash;
    if (hash && hash.length > 1) {
      const targetId = hash.substring(1); // Remove '#'
      const target = document.getElementById(targetId);
      if (target) {
        // Small delay to ensure page is fully rendered
        setTimeout(() => {
          const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
          target.scrollIntoView({ 
            behavior: prefersReducedMotion ? 'auto' : 'smooth', 
            block: 'start' 
          });
        }, 100);
      }
    }
  }
  
  /**
   * Initialize bottom sheet interactions
   */
  function initBottomSheet() {
    const containers = document.querySelectorAll('.outline-bottom-sheet-container:not(.js-initialized)');
    
    containers.forEach((container) => {
      container.classList.add('js-initialized');
      
      const trigger = container.querySelector('.outline-trigger') as HTMLButtonElement;
      const closeBtn = container.querySelector('.outline-close') as HTMLButtonElement;
      const backdrop = container.querySelector('.outline-backdrop') as HTMLElement;
      const sheet = container.querySelector('.outline-bottom-sheet') as HTMLElement;
      
      if (!trigger || !closeBtn || !backdrop || !sheet) return;
      
      let scrollY = 0;
      
      // Handle scroll-based visibility
      const handleVisibility = () => {
        if (window.scrollY > 300) {
          container.classList.add('scrolled');
        } else {
          container.classList.remove('scrolled');
        }
      };
      
      // Initialize visibility
      window.addEventListener('scroll', handleVisibility, { passive: true });
      handleVisibility();

      // Open sheet
      function openSheet() {
        // Save scroll position and lock body
        scrollY = window.scrollY;
        document.body.style.position = 'fixed';
        document.body.style.top = `-${scrollY}px`;
        document.body.style.left = '0';
        document.body.style.right = '0';
        document.body.style.overflow = 'hidden';
        
        container.classList.add('open');
        trigger.setAttribute('aria-expanded', 'true');
      }
      
      // Close sheet
      function closeSheet() {
        container.classList.remove('open');
        trigger.setAttribute('aria-expanded', 'false');
        
        // Restore body scroll
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.left = '';
        document.body.style.right = '';
        document.body.style.overflow = '';
        window.scrollTo(0, scrollY);
      }
      
      // Event listeners
      trigger.addEventListener('click', openSheet);
      closeBtn.addEventListener('click', closeSheet);
      backdrop.addEventListener('click', closeSheet);
      
      // ESC key to close
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && container.classList.contains('open')) {
          closeSheet();
        }
      });
      
      // Handle touch gestures (swipe down to close)
      let startY = 0;
      let currentY = 0;
      let isDragging = false;
      
      sheet.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        startY = touch.clientY;
        isDragging = true;
      }, { passive: true });
      
      sheet.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        
        const touch = e.touches[0];
        currentY = touch.clientY;
        const delta = currentY - startY;
        
        // Only allow dragging down
        if (delta > 0) {
          sheet.style.transform = `translateY(${delta}px)`;
        }
      }, { passive: true });
      
      sheet.addEventListener('touchend', () => {
        if (!isDragging) return;
        isDragging = false;
        
        const delta = currentY - startY;
        sheet.style.transform = '';
        
        // If dragged more than 100px down, close
        if (delta > 100) {
          closeSheet();
        }
      }, { passive: true });
    });
  }
  
  /**
   * Setup scroll listener to render container when user scrolls
   */
  function setupScrollListener() {
    if (scrollListenerAdded) return;
    
    const handleScroll = () => {
      if (window.scrollY > 300 && !containerRendered) {
        renderBottomSheet();
        // Remove listener after rendering
        window.removeEventListener('scroll', handleScroll);
      }
    };
    
    window.addEventListener('scroll', handleScroll, { passive: true });
    scrollListenerAdded = true;
    
    // Also check immediately in case user already scrolled
    handleScroll();
  }
  
  /**
   * Reset state on page navigation
   */
  function resetState() {
    containerRendered = false;
    scrollListenerAdded = false;
    
    // Remove any existing containers
    const existingContainers = document.querySelectorAll('.outline-bottom-sheet-container');
    existingContainers.forEach(container => container.remove());
  }
  
  // Initialize on load
  setupScrollListener();
  
  // Scroll to hash on initial load (if present)
  scrollToHashIfPresent();
  
  // Listen for browser back/forward navigation
  window.addEventListener('popstate', scrollToHashIfPresent);
  
  // Reset and reinitialize after view transitions
  document.addEventListener('astro:page-load', () => {
    resetState();
    setupScrollListener();
    // Scroll to hash after page transition (if present)
    scrollToHashIfPresent();
  });
</script>
